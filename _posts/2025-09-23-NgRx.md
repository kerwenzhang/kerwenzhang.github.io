---                
layout: post                
title: "NgRx学习笔记"                
date:   2025-9-23 18:30:00                 
categories: "Web"                
catalog: true                
tags:                 
    - Web                
---      
在构建复杂的企业级Angular应用时，状态管理成为架构设计的核心挑战。随着应用规模扩大，组件间状态共享、异步操作协同和数据流一致性等问题日益突出。NgRx作为基于Redux模式的响应式状态管理库，已成为Angular生态的状态管理解决方案首选。   

NgRx建立在严格的单向数据流基础上，其核心架构包含五个关键要素：   

1. Store：单一数据源（Single Source of Truth）  
    Store作为不可变的中央状态容器，存储整个应用状态树。在Angular中通过依赖注入使用：  
2. Actions：状态变更描述器  
    Actions是描述状态变更事件的纯对象，使用createAction工厂函数创建：
3. Reducers：状态变更处理器  
Reducers是纯函数，根据Action处理状态转换：  
4. Selectors：状态查询器  
Selectors提供高效的状态查询机制，支持组合和记忆化：  
5. Effects：副作用处理器  
Effects隔离异步操作，保持Reducer纯净：  

# Demo 

1. 生成一个新项目

        ng new my-angular-app --standalone=false --routing --style=css

2. 安装依赖

        npm install @ngrx/store --save    

3. 在app下创建一个名为counter.actions.ts的新文件，以描述增加、减少和重置其值的计数器操作。  

        import { createAction } from '@ngrx/store';

        export const increment = createAction('[Counter Component] Increment');
        export const decrement = createAction('[Counter Component] Decrement');
        export const reset = createAction('[Counter Component] Reset');

4. 在app下创建一个名为counter.reducer.ts的新文件，定义一个 reducer 函数，根据提供的 action 来处理计数器值的变化。  

        import { createReducer, on } from '@ngrx/store';
        import { increment, decrement, reset } from './counter.actions';

        export const initialState = 0;

        export const counterReducer = createReducer(
            initialState,
            on(increment, (state) => state + 1),
            on(decrement, (state) => state - 1),
            on(reset, (state) => 0)
        );

5. 在`app.module.ts`中导入源StoreModule文件@ngrx/store和counter.reducer文件。  

        import { StoreModule } from '@ngrx/store';
        import { counterReducer } from './counter.reducer';

6. 在 AppModule 的 imports 数组中添加 StoreModule.forRoot 函数，并传入一个包含 count 和用于管理计数器状态的 counterReducer 的对象。StoreModule.forRoot() 方法会注册全局的提供者，使整个应用程序都能访问 Store。  

        import { BrowserModule } from '@angular/platform-browser';
        import { NgModule } from '@angular/core';

        import { AppComponent } from './app.component';

        import { StoreModule } from '@ngrx/store';
        import { counterReducer } from './counter.reducer';

        @NgModule({
            declarations: [AppComponent],
            imports: [BrowserModule, StoreModule.forRoot({ count: counterReducer })],
            providers: [],
            bootstrap: [AppComponent],
        })
        export class AppModule {}

7. 在 app 文件夹中创建一个名为 my-counter 的新文件夹，并在其中新建一个名为 my-counter.component.ts 的文件，用于定义一个名为 MyCounterComponent 的新组件。该组件将渲染按钮，允许用户更改计数状态。同时，在同一文件夹中创建一个名为 my-counter.component.html 的文件，用于定义该组件的模板页面。  

        import { Component } from '@angular/core';
        import { Observable } from 'rxjs';

        @Component({
            selector: 'app-my-counter',
            standalone: false,
            templateUrl: './my-counter.component.html',
            styleUrl: './my-counter.component.css'
        })
        export class MyCounterComponent {
            count$: Observable<number>

            constructor() {
                // TODO: Connect `this.count$` stream to the current store `count` state
            }

            increment() {
                // TODO: Dispatch an increment action
            }

            decrement() {
                // TODO: Dispatch a decrement action
            }

            reset() {
                // TODO: Dispatch a reset action
            }
        }

    my-counter.component.html

        <button (click)="increment()">Increment</button>

        <div>Current Count: {{ count$ | async }}</div>

        <button (click)="decrement()">Decrement</button>

        <button (click)="reset()">Reset Counter</button>

8. 将新组件添加到 AppModule 的声明中并在模板app.component.html中声明它：  

        <app-my-counter></app-my-counter>

    app.module.ts

        import { BrowserModule } from '@angular/platform-browser';
        import { NgModule } from '@angular/core';

        import { AppComponent } from './app.component';

        import { StoreModule } from '@ngrx/store';
        import { counterReducer } from './counter.reducer';
        import { MyCounterComponent } from './my-counter/my-counter.component';

        @NgModule({
            declarations: [AppComponent, MyCounterComponent],
            imports: [BrowserModule, StoreModule.forRoot({ count: counterReducer })],
            providers: [],
            bootstrap: [AppComponent],
        })
        export class AppModule {}

9. 将 store 注入到 MyCounterComponent 中，并将 count$ 连接到 store 的 count 状态。通过向 store 分发 action 来实现 increment（递增）、decrement（递减）和 reset（重置）方法。  

        import { Component } from '@angular/core';
        import { Store } from '@ngrx/store';
        import { Observable } from 'rxjs';
        import { decrement, increment, reset } from '../counter.actions';

        @Component({
            selector: 'app-my-counter',
            standalone: false,
            templateUrl: './my-counter.component.html',
            styleUrl: './my-counter.component.css'
        })
        export class MyCounterComponent {
            count$: Observable<number>;

            constructor(private store: Store<{ count: number }>) {
                this.count$ = store.select('count');
            }

            increment() {
                this.store.dispatch(increment());
            }

            decrement() {
                this.store.dispatch(decrement());
            }

            reset() {
                this.store.dispatch(reset());
            }
        }

# Store
NgRx Store 提供状态管理功能，通过使用单一状态和操作来表达状态变化，从而创建可维护、明确的应用程序。NgRx Store是全局的、覆盖整个应用程序的，NgRx Signals，则提供了本地状态管理的解决方案。   

是否需要NgRx Store, 应考虑以下原则:  
+ 共享（Shared）：被多个组件和服务访问的状态。
+ 持久化（Hydrated）：从外部存储中持久化并重新加载的状态。
+ 可用（Available）：在重新进入路由时需要保持可用的状态。
+ 检索（Retrieved）：必须通过side-effect（如 API 请求）来获取的状态。
+ 受影响（Impacted）：受到其他来源的动作影响的状态。  

下图表示 NgRx 中应用程序状态的整体流程。  
![img](https://github.com/kerwenzhang/kerwenzhang.github.io/blob/master/_posts/image/ngrx1.png?raw=true)  


1. 生成一个新项目

        ng new book --standalone=false --routing --style=css

2. 安装依赖

        npm install @ngrx/store --save    
  
3. 生成`BookList`组件

        ng g c BookList

4. 在`book-list`文件夹中添加一个`books.model.ts`文件来定义Book接口

        export interface Book {
            id: string;
            volumeInfo: {
            title: string;
            authors: Array<string>;
            };
        }

5. 在app下创建`state`文件夹来管理状态.创建`books.actions.ts`来描述book相关的actions。Book actions包括图书列表的获取、添加图书和移除图书操作。  

        import { createActionGroup, props } from '@ngrx/store';
        import { Book } from '../book-list/books.model';

        export const BooksActions = createActionGroup({
            source: 'Books',
            events: {
                'Add Book': props<{ bookId: string }>(),
                'Remove Book': props<{ bookId: string }>(),
            },
        });

        export const BooksApiActions = createActionGroup({
            source: 'Books API',
            events: {
                'Retrieved Book List': props<{ books: ReadonlyArray<Book> }>(),
            },
        });

6. 在State下创建`books.reducer.ts`在此文件中，定义一个 reducer 函数，用于处理从State中获取图书列表的操作，并相应地更新状态state。

        import { createReducer, on } from '@ngrx/store';

        import { BooksApiActions } from './books.actions';
        import { Book } from '../book-list/books.model';

        export const initialState: ReadonlyArray<Book> = [];

        export const booksReducer = createReducer(
            initialState,
            on(BooksApiActions.retrievedBookList, (_state, { books }) => books)
        );

7. 在 state 文件夹中创建另一个名为 `collection.reducer.ts` 的文件，用于处理更改图书收藏collection的相关操作。定义一个 reducer 函数来处理添加操作，通过将图书的 ID 添加到收藏中。使用同一个 reducer 函数处理移除操作，通过根据图书 ID 过滤收藏数组来实现移除。   

        import { createReducer, on } from '@ngrx/store';
        import { BooksActions } from './books.actions';

        export const initialState: ReadonlyArray<string> = [];

        export const collectionReducer = createReducer(
            initialState,
            on(BooksActions.removeBook, (state, { bookId }) =>
                state.filter((id) => id !== bookId)
            ),
            on(BooksActions.addBook, (state, { bookId }) => {
                if (state.indexOf(bookId) > -1) return state;

                return [...state, bookId];
            })
        );

8. 修改app.module.ts

        import { NgModule } from '@angular/core';
        import { BrowserModule } from '@angular/platform-browser';

        import { AppRoutingModule } from './app-routing.module';
        import { AppComponent } from './app.component';
        import { BookListComponent } from './book-list/book-list.component';
        import { HttpClientModule } from '@angular/common/http';
        import { booksReducer } from './state/books.reducer';
        import { collectionReducer } from './state/collection.reducer';
        import { StoreModule } from '@ngrx/store';

        @NgModule({
            declarations: [
                AppComponent,
                BookListComponent
            ],
            imports: [
                BrowserModule,
                AppRoutingModule,
                StoreModule.forRoot({ books: booksReducer, collection: collectionReducer }),
                HttpClientModule,
            ],
            providers: [],
            bootstrap: [AppComponent]
        })
        export class AppModule { }

9. 创建图书列表和收藏选择器`books.selectors.ts`，以确保我们能够从 store 中获取正确的信息。如你所见，selectBookCollection 选择器通过组合另外两个选择器来构建其返回值。

        import { createSelector, createFeatureSelector } from '@ngrx/store';
        import { Book } from '../book-list/books.model';

        export const selectBooks = createFeatureSelector<ReadonlyArray<Book>>('books');

        export const selectCollectionState = createFeatureSelector<ReadonlyArray<string>>('collection');

        export const selectBookCollection = createSelector(
            selectBooks,
            selectCollectionState,
            (books, collection) => {
                return collection.map((id) => books.find((book) => book.id === id)!);
            }
        );

10. 在 book-list 文件夹中，创建服务`books.service.ts`，用于从 API 获取图书列表所需的数据。该服务将调用 Google Books API 并返回图书列表。  

        ng g s book-list\Book

    books.service.ts  

        import { HttpClient } from '@angular/common/http';
        import { Injectable } from '@angular/core';

        import { Observable } from 'rxjs';
        import { map } from 'rxjs/operators';
        import { Book } from './books.model';

        @Injectable({
            providedIn: 'root'
        })
        export class BookService {

            constructor(private http: HttpClient) {}

            getBooks(): Observable<Array<Book>> {
                return this.http.get<{ items: Book[] }>(
                    'https://www.googleapis.com/books/v1/volumes?maxResults=5&orderBy=relevance&q=oliver%20sacks'
                )
                .pipe(map((books) => books.items || []));
            }
        }

11. 更新`book-list.component.html`以派发添加（add）事件。

        <div
            class="book-item"
            *ngFor="let book of books"
        >
            <p>{{book.volumeInfo.title}}</p><span> by {{book.volumeInfo.authors}}</span>
            <button
                (click)="add.emit(book.id)"
                data-test="add-button"
            >Add to Collection</button>
        </div>

12. 更新`book-list.component.ts`  

        import { Component, EventEmitter, Input, Output } from '@angular/core';
        import { Book } from './books.model';

        @Component({
            selector: 'app-book-list',
            standalone: false,
            templateUrl: './book-list.component.html',
            styleUrl: './book-list.component.css'
        })
        export class BookListComponent {
            @Input() books: ReadonlyArray<Book> = [];
            @Output() add = new EventEmitter<string>();
        }

13. 创建BookCollection组件  

        ng g c BookCollection

14. 更新book-collection.component.html  

        <div 
        class="book-item"
        *ngFor="let book of books"
        >
            <p>{{book.volumeInfo.title}}</p><span> by {{book.volumeInfo.authors}}</span>
            <button
                (click)="remove.emit(book.id)"
                data-test="remove-button"
            >Remove from Collection</button>
        </div>

15. 更新book-collection.component.ts  

        import { Component, EventEmitter, Input, Output } from '@angular/core';
        import { Book } from '../book-list/books.model';

        @Component({
            selector: 'app-book-collection',
            standalone: false,
            templateUrl: './book-collection.component.html',
            styleUrl: './book-collection.component.css'
        })
        export class BookCollectionComponent {
            @Input() books: ReadonlyArray<Book> = [];
            @Output() remove = new EventEmitter<string>();
        }

16. 将 BookListComponent 和 BookCollectionComponent 添加到 AppComponent 的模板中，并在 app.module.ts 中的 declarations 中进行声明

    <h2>Books</h2>
    <app-book-list class="book-list" [books]="(books$ | async)!" (add)="onAdd($event)"></app-book-list>

    <h2>My Collection</h2>
    <app-book-collection class="book-collection" [books]="(bookCollection$ | async)!" (remove)="onRemove($event)">
    </app-book-collection>

17. 在 AppComponent 类中，添加选择器selector以及在调用添加或移除方法时需要派发的对应 action。然后订阅 Google Books API，以便更新状态。（这部分通常应该由 NgRx Effects 处理）  


        import { Component, OnInit } from '@angular/core';
        import { Store } from '@ngrx/store';

        import { selectBookCollection, selectBooks } from './state/books.selectors';
        import { BooksActions, BooksApiActions } from './state/books.actions';
        import { BookService } from './book-list/book.service';

        @Component({
            selector: 'app-root',
            templateUrl: './app.component.html',
            standalone: false,
            styleUrl: './app.component.css'
        })
        export class AppComponent implements OnInit {
            books$: any;
            bookCollection$: any;

            constructor(private booksService: BookService, private store: Store) {}

            ngOnInit() {
                this.books$ = this.store.select(selectBooks);
                this.bookCollection$ = this.store.select(selectBookCollection);
                
                this.booksService
                .getBooks()
                .subscribe((books) =>
                    this.store.dispatch(BooksApiActions.retrievedBookList({ books }))
                );
            }

            onAdd(bookId: string) {
                this.store.dispatch(BooksActions.addBook({ bookId }));
            }

            onRemove(bookId: string) {
                this.store.dispatch(BooksActions.removeBook({ bookId }));
            }
        }



# Reference
[NgRx](https://ngrx.io/docs)  
[Angular与NgRx状态管理: 最佳实践解析](https://www.jianshu.com/p/7a966d2e791d)  
[Level Up Your NgRx Skills With 10 Time-Tested Best Practices](https://angularexperts.io/blog/level-up-your-ng-rx-skills-with-10-time-tested-best-practices)  
[NgRx — Best Practices for Enterprise Angular Applications](https://wesleygrimes.com/angular/2018/05/30/ngrx-best-practices-for-enterprise-angular-applications)  
[Simplify State Management with NgRx in Angular | NgRx Guide](https://codezup.com/simplifying-state-management-ngrx-angular-guide/)  
