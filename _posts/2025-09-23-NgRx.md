---                
layout: post                
title: "NgRx学习笔记"                
date:   2025-9-23 18:30:00                 
categories: "Web"                
catalog: true                
tags:                 
    - Web                
---      
在构建复杂的企业级Angular应用时，状态管理成为架构设计的核心挑战。随着应用规模扩大，组件间状态共享、异步操作协同和数据流一致性等问题日益突出。NgRx作为基于Redux模式的响应式状态管理库，已成为Angular生态的状态管理解决方案首选。   

NgRx建立在严格的单向数据流基础上，其核心架构包含五个关键要素：   

1. Store：单一数据源（Single Source of Truth）  
    Store作为不可变的中央状态容器，存储整个应用状态树。在Angular中通过依赖注入使用：  
2. Actions：状态变更描述器  
    Actions是描述状态变更事件的纯对象，使用createAction工厂函数创建：
3. Reducers：状态变更处理器  
Reducers是纯函数，根据Action处理状态转换：  
4. Selectors：状态查询器  
Selectors提供高效的状态查询机制，支持组合和记忆化：  
5. Effects：副作用处理器  
Effects隔离异步操作，保持Reducer纯净：  


下图表示 NgRx 中应用程序状态的整体流程。  
![img](https://github.com/kerwenzhang/kerwenzhang.github.io/blob/master/_posts/image/ngrx1.png?raw=true)  


# Store
NgRx Store 提供状态管理功能，通过使用单一状态和操作来表达状态变化，从而创建可维护、明确的应用程序。NgRx Store是全局的、覆盖整个应用程序的，NgRx Signals，则提供了本地状态管理的解决方案。   

是否需要NgRx Store, 应考虑以下原则:  
+ 共享（Shared）：被多个组件和服务访问的状态。
+ 持久化（Hydrated）：从外部存储中持久化并重新加载的状态。
+ 可用（Available）：在重新进入路由时需要保持可用的状态。
+ 检索（Retrieved）：必须通过side-effect（如 API 请求）来获取的状态。
+ 受影响（Impacted）：受到其他来源的动作影响的状态。  



# Actions
动作（Actions） 是 NgRx 中的主要构建模块之一, 用于表达应用程序中发生的独特事件。从用户与页面的交互、通过网络请求的外部交互，到与设备 API 的直接交互，这些事件及更多内容都通过动作来描述。   
动作在 NgRx 的许多领域中都有应用。它们是 NgRx 中许多系统的输入和输出。动作帮助你理解应用程序中事件是如何被处理的。  
在 NgRx 中，一个动作由一个简单的接口组成：  

    interface Action {
        type: string;
    }

该接口只有一个属性：type，它是一个字符串，用于描述将在应用程序中派发的动作。type 的值通常采用 [来源] 事件 的形式，用于提供动作的类别和来源的上下文。你可以为动作添加其他属性，以提供更多上下文或元数据。   
以下是示例, 这个动作描述了在与后端 API 交互后认证成功所触发的事件。：  

    {
        type: '[Auth API] Login Success'
    }

下面这个动作描述了用户在登录页面点击登录按钮以尝试认证时触发的事件。username 和 password 是来自登录页面的附加元数据。  

    {
        type: '[Login Page] Login',
        username: string;
        password: string;
    }

编写动作的规则 在应用程序中编写良好的动作需要遵循以下规则：  

+ 提前编写：在开发功能之前编写动作，以便理解并共享所实现功能的知识。
+ 分类：根据事件来源对动作进行分类。
+ 多写：动作编写成本低，写得越多，越能清晰表达应用流程。
+ 事件驱动：捕捉事件而非命令，分离事件的描述与事件的处理。
+ 描述性Descriptive：提供针对唯一事件的上下文信息，有助于使用开发者工具进行调试。

示例：发起登录请求的动作  

    // login-page.actions.ts
    import { createAction, props } from '@ngrx/store';

    export const login = createAction(
        '[Login Page] Login',
        props<{ username: string; password: string }>()
    );

createAction 函数返回一个函数，调用该函数会返回一个符合 Action 接口结构的对象。props 方法用于定义处理该动作所需的附加数据。动作创建器提供了一种一致且类型安全的方式来构造将要派发的动作。  
派发动作：  

    // login-page.component.ts
    onSubmit(username: string, password: string) {
        store.dispatch(login({ username: username, password: password }));
    }

login 动作创建器接收一个包含 username 和 password 的对象，并返回一个包含 type 属性的普通 JavaScript 对象，同时附带 username 和 password 属性。  

根据信号变化派发动作   
还可以派发返回动作的函数，其属性值由信号派生：  

    // book.component.ts
    class BookComponent {
        bookId = input.required<number>();

        constructor(store: Store) {
            store.dispatch(() => loadBook({ id: this.bookId() }));
        }
    }

dispatch 会在初始时执行，并在 bookId 变化时再次执行。如果 dispatch 在注入上下文中调用，则信号会被追踪，直到上下文销毁。在上述示例中，即为 BookComponent 被销毁时。

# Reducers
在 NgRx 中，Reducer 负责处理应用程序中从一个状态到下一个状态的转换。Reducer 函数通过判断动作（Action）的类型来决定如何处理这些状态转换。    
Reducer 是纯函数，它对相同的输入总是产生相同的输出。它们没有副作用side effects，并以同步方式处理每一次状态转换。每个 reducer 函数接收最新派发的 Action 和当前状态，并决定是返回一个新的修改后的状态，还是保持原状态不变。  

每个由 reducer 管理的状态片段通常包含以下几个部分：  

+ 一个定义状态结构的接口或类型
+ 参数，包括初始状态或当前状态，以及当前动作
+ 用于处理与特定动作相关的状态变化的函数

下面是一个用于处理记分板状态的动作集合及其对应的 reducer 函数示例。  
1. 定义一些用于操作状态的动作  

        import { createAction, props } from '@ngrx/store';

        export const homeScore = createAction('[Scoreboard Page] Home Score');
        export const awayScore = createAction('[Scoreboard Page] Away Score');
        export const resetScore = createAction('[Scoreboard Page] Score Reset');
        export const setScores = createAction('[Scoreboard Page] Set Scores', props<{game: Game}>());

2. 创建 reducer 文件，导入动作并定义状态结构  

        import { Action, createReducer, on } from '@ngrx/store';
        import * as ScoreboardPageActions from '../actions/scoreboard-page.actions';

        export interface State {
            home: number;
            away: number;
        }

    可以根据需要捕获的数据定义状态结构，无论是简单类型（如数字），还是包含多个属性的复杂对象。   

3. 设置初始状态   
    初始状态为状态赋予初始值，或者在当前状态未定义时提供默认值。你可以创建并导出一个变量，用于捕获初始状态及其默认值。  

        export const initialState: State = {
            home: 0,
            away: 0,
        };

    在这个例子中，home 和 away 属性的初始值都是 0。    

4. 创建 reducer 函数   
    Reducer 函数的职责是以不可变的方式处理状态转换。使用 createReducer 函数创建一个用于管理记分板状态的 reducer 函数。  

        export const scoreboardReducer = createReducer(
            initialState,
            on(ScoreboardPageActions.homeScore, state => ({ ...state, home: state.home + 1 })),
            on(ScoreboardPageActions.awayScore, state => ({ ...state, away: state.away + 1 })),
            on(ScoreboardPageActions.resetScore, state => ({ home: 0, away: 0 })),
            on(ScoreboardPageActions.setScores, (state, { game }) => ({ home: game.home, away: game.away }))
        );

    在上面的示例中，reducer 处理了四个动作：`[Scoreboard Page] Home Score`、`[Scoreboard Page] Away Score`、`[Scoreboard Page] Score Reset` 和 `[Scoreboard Page] Set Scores`。每个动作都是强类型的，并且都以不可变的方式处理状态转换。这意味着状态转换不会修改原始状态，而是使用扩展运算符返回一个新的状态对象。扩展语法会将当前状态的属性复制到新对象中，从而创建一个新的引用。这确保每次状态变化都会生成一个新状态，从而保持状态变化的纯粹性。同时也有助于引用完整性，确保状态变化时旧的引用被丢弃。  

    注意：扩展运算符只进行浅拷贝，无法处理深层嵌套对象。若要确保不可变性，需要对对象的每一层进行拷贝。可以使用如 lodash 和 immer 等库来处理深拷贝。  

    当一个动作被派发时，所有已注册的 reducer 都会接收到该动作。是否处理该动作由 on 函数决定，它将一个或多个动作与特定的状态变化关联起来。  

5. 注册根状态 root state   
    应用程序的状态定义为一个大型对象。注册 reducer 函数来管理部分状态，只是定义了该对象中的键及其对应的值。要在应用程序中注册全局 Store，请使用 StoreModule.forRoot() 方法，并传入一个键值对映射来定义你的状态。StoreModule.forRoot() 会注册应用程序的全局提供者，包括你在组件和服务中注入的 Store 服务，用于派发动作和选择状态片段。  


        import { NgModule } from '@angular/core';
        import { StoreModule } from '@ngrx/store';
        import { scoreboardReducer } from './reducers/scoreboard.reducer';

        @NgModule({
            imports: [
                StoreModule.forRoot({ game: scoreboardReducer })
            ],
        })
        export class AppModule {}

    使用 StoreModule.forRoot() 注册状态可以确保这些状态在应用程序启动时就被定义。通常你会注册那些需要在整个应用中立即可用的根状态。   

    注册特性状态（Registering feature state）   
    feature状态的行为方式与根状态相同，但它允许你在应用程序中为特定功能区域定义状态。你的整个状态是一个大型对象，而特性状态会在该对象中注册额外的键和值。  

    通过查看一个示例状态对象，可以看到特性状态如何让你的状态逐步构建。我们先从一个空状态对象开始。  

        import { NgModule } from '@angular/core';
        import { StoreModule } from '@ngrx/store';

        @NgModule({
            imports: [
                StoreModule.forRoot({})
            ],
        })
        export class AppModule {}

    这会将你的应用注册为一个空的根状态对象：  

        {}

    现在使用 scoreboardReducer 和一个名为 ScoreboardModule 的Module 来注册额外的状态。  
    scoreboard.reducer.ts  

        export const scoreboardFeatureKey = 'game';

    scoreboard.module.ts  

        import { NgModule } from '@angular/core';
        import { StoreModule } from '@ngrx/store';
        import { scoreboardFeatureKey, scoreboardReducer } from './reducers/scoreboard.reducer';
        
        @NgModule({
        imports: [
            StoreModule.forFeature(scoreboardFeatureKey, scoreboardReducer)
        ],
        })
        export class ScoreboardModule {}

    将 ScoreboardModule 添加到 AppModule 中，以便在应用启动时立即加载该状态：  

        import { NgModule } from '@angular/core';
        import { StoreModule } from '@ngrx/store';
        import { ScoreboardModule } from './scoreboard/scoreboard.module';

        @NgModule({
            imports: [
                StoreModule.forRoot({}),
                ScoreboardModule
            ],
        })
        export class AppModule {}

    加载特性后，game 键就会成为状态对象中的一个属性，并由状态管理：  

        {
            game: { home: 0, away: 0 }
        }


    Reducer 的唯一职责是决定针对某个动作应进行哪些状态转换。  
    在应用中，还需要处理一些非纯动作（如 AJAX 请求），在 NgRx 中我们称之为 Effects（副作用）。  

# Selectors  
选择器（Selectors）是用于从 Store 状态中获取片段的纯函数。@ngrx/store 提供了一些辅助函数来优化这种选择过程。选择器在选择状态片段时具备以下优势：
+ 可移植性（Portability）  
+ 记忆化（Memoization）
+ 组合性（Composition）
+ 可测试性（Testability）
+ 类型安全（Type Safety）

当使用 createSelector 和 createFeatureSelector 函数时，@ngrx/store 会跟踪你选择器函数最近调用时的参数。由于选择器是纯函数，当参数匹配时可以直接返回上一次的结果，而无需重新执行选择器函数。这种做法称为 记忆化（Memoization），在处理计算开销较大的选择器时尤其有性能优势。  

使用选择器获取单个状态片段  

    import { createSelector } from '@ngrx/store';

    export interface FeatureState {
        counter: number;
    }

    export interface AppState {
        feature: FeatureState;
    }

    export const selectFeature = (state: AppState) => state.feature;

    export const selectFeatureCount = createSelector(
        selectFeature,
        (state: FeatureState) => state.counter
    );

使用选择器获取多个状态片段  
createSelector 可以基于多个状态片段从状态中选择数据。它最多可以接受 8 个选择器函数，用于更完整的状态选择。  

例如，假设你在状态中有一个 selectedUser 对象，还有一个 allBooks 数组。你希望展示当前用户的所有图书。  

你可以使用 createSelector 来实现这一目标。即使你更新了 allBooks，你的可见图书也会始终保持最新。如果有选中的用户，它只显示该用户的图书；如果没有选中用户，则显示所有图书。  

    import { createSelector } from '@ngrx/store';

    export interface User {
        id: number;
        name: string;
    }

    export interface Book {
        id: number;
        userId: number;
        name: string;
    }

    export interface AppState {
        selectedUser: User;
        allBooks: Book[];
    }

    export const selectUser = (state: AppState) => state.selectedUser;
    export const selectAllBooks = (state: AppState) => state.allBooks;

    export const selectVisibleBooks = createSelector(
        selectUser,
        selectAllBooks,
        (selectedUser: User, allBooks: Book[]) => {
            if (selectedUser && allBooks) {
            return allBooks.filter((book: Book) => book.userId === selectedUser.id);
            } else {
            return allBooks;
            }
        }
    );

使用字典形式的选择器  
createSelector 还支持传入一个选择器字典而不使用 projector 函数。在这种情况下，它会自动生成一个 projector，将输入选择器的结果映射为一个字典。  

    // 返回类型为 { books: Book[]; query: string }
    const selectBooksPageViewModel = createSelector({
        books: selectBooks, // 返回类型 Book[]
        query: selectQuery, // 返回类型 string
    });


选择特性状态（Selecting Feature States）  
createFeatureSelector 是一个便捷方法，用于返回顶层的特性状态。它会为某个特性状态片段返回一个带类型的选择器函数。  

    import { createSelector, createFeatureSelector } from '@ngrx/store';

    export const featureKey = 'feature';

    export interface FeatureState {
        counter: number;
    }

    export const selectFeature = createFeatureSelector<FeatureState>(featureKey);

    export const selectFeatureCount = createSelector(
        selectFeature,
        (state: FeatureState) => state.counter
    );

使用 Feature Creator 可以为每个特性状态属性自动生成顶层选择器和子选择器。  

重置记忆化选择器（Resetting Memoized Selectors）  
通过 createSelector 或 createFeatureSelector 创建的选择器函数，初始时其记忆化值为 null。当选择器首次被调用时，它会计算结果并将该值存储在内存中。之后如果使用相同参数再次调用，它会直接返回记忆化值，而不会重新计算。如果参数发生变化，它会重新计算并更新记忆化值。  

    import { createSelector } from '@ngrx/store';

    export interface State {
    counter1: number;
    counter2: number;
    }

    export const selectCounter1 = (state: State) => state.counter1;
    export const selectCounter2 = (state: State) => state.counter2;

    export const selectTotal = createSelector(
        selectCounter1,
        selectCounter2,
        (counter1, counter2) => counter1 + counter2
    );


    let state = { counter1: 3, counter2: 4 };

    selectTotal(state); // 计算 3 + 4，返回 7，并将 7 存为记忆化值
    selectTotal(state); // 返回记忆化值 7，不重新计算

    state = { ...state, counter2: 5 };

    selectTotal(state); // 计算 3 + 5，返回 8，并更新记忆化值为 8

选择器的记忆化值会一直保留在内存中。如果该值是一个不再需要的大型数据集，可以通过调用选择器的 release 方法将其重置为 null，以释放内存。  

    selectTotal(state); // 返回 8
    selectTotal.release(); // 清除记忆化值，变为 null

选择器使你能够为应用程序状态构建读取模型。在 CQRS 架构模式中，NgRx 将读取模型（selectors）与写入模型（reducers）分离。  

# effects
Effects 是一种由 RxJS 驱动的 Store 副作用模型。它通过流的方式提供新的动作来源，以便根据外部交互（如网络请求、WebSocket 消息和基于时间的事件）来更新状态。    
在基于服务的 Angular 应用中，组件通常直接通过服务与外部资源交互。而使用 Effects，可以将这些服务的交互逻辑从组件中分离出来。Effects 主要用于处理诸如数据获取、产生多个事件的长时间任务，以及其他组件无需显式了解的外部交互。  
核心概念  
+ Effects 将副作用与组件隔离，使组件更纯粹，仅负责选择状态和派发动作。
+ Effects 是长时间运行的服务，它监听 Store 中派发的所有动作的可观察流。
+ Effects 会根据动作类型进行过滤，只处理感兴趣的动作（通过操作符实现）。
+ Effects 执行任务（同步或异步），并返回新的动作。

与组件内副作用Component-Based Side Effects的对比
在基于服务的应用中，组件通过多个服务来获取数据，这些服务可能依赖其他服务来管理不同的数据集。组件使用这些服务来执行任务，因此承担了许多职责。  
假设你的应用用于管理电影，下面是一个用于获取并展示电影列表的组件：  

    import { Component, inject, OnInit } from '@angular/core';
    import { CommonModule } from '@angular/common';

    @Component({
        template: `
            <li *ngFor="let movie of movies">
            {{ movie.name }}
            </li>
        `,
        imports: [CommonModule],
    })
    export class MoviesPageComponent implements OnInit {
        private moviesService = inject(MoviesService);
        protected movies: Movie[] = [];

        ngOnInit() {
            this.movieService.getAll()
            .subscribe(movies => this.movies = movies);
        }
    }

对应的服务如下：  

    import { Injectable, inject } from '@angular/core';
    import { HttpClient } from '@angular/common/http';
    import { Observable } from 'rxjs';

    @Injectable({
        providedIn: 'root',
    })
    export class MoviesService {
        private http = inject(HttpClient);

        getAll(): Observable {
            return this.http.get('/movies');
        }
    }

该组件承担了多个职责：  
+ 管理电影的状态
+ 使用服务执行副作用（调用外部 API 获取电影）
+ 在组件内部修改电影状态  

使用 Effects 简化组件职责  
当 Effects 与 Store 一起使用时，可以显著减少组件的职责。在大型应用中，这尤为重要，因为你可能有多个数据源、多个服务来获取数据，甚至服务之间也存在依赖关系。  
Effects 负责处理外部数据和交互，使服务变得更轻量，仅专注于执行外部任务。接下来我们重构组件，将共享的电影数据放入 Store 中，由 Effects 负责获取电影数据。  

    import { Component, inject, OnInit } from '@angular/core';
    import { CommonModule } from '@angular/common';

    @Component({
        template: `
            <div *ngFor="let movie of movies$ | async">
            {{ movie.name }}
            </div>
        `,
        imports: [CommonModule],
    })
    export class MoviesPageComponent implements OnInit {
        private store = inject(Store<{ movies: Movie[] }>);
        protected movies$ = this.store.select(state => state.movies);

        ngOnInit() {
            this.store.dispatch({ type: '[Movies Page] Load Movies' });
        }
    }

电影数据仍然通过 MoviesService 获取，但组件不再关心具体的获取和加载过程。它只负责声明加载意图（ declaring its intent to load movies），并通过选择器访问电影列表数据。异步获取电影的逻辑由 Effects 处理。这样组件更容易测试，也更专注于展示数据而非管理数据。    

编写 Effects（副作用处理器）  
编写 Effects（副作用处理器） 为了将副作用从组件中隔离出来，你可以创建 NgRx 的 Effects 来监听事件并执行任务。  

Effects 是可注入的服务类，具有以下几个关键部分：  

+ 一个可注入的 Actions 服务，它提供一个可观察流，包含每次状态更新后派发的动作。  
+ 使用 createEffect 函数为可观察流附加元数据。该元数据用于注册这些流，使其订阅 Store。任何从 effect 流中返回的动作都会再次派发到 Store。  
+ 使用可管道的 ofType 操作符对动作进行过滤。ofType 接收一个或多个动作类型作为参数，用于筛选需要处理的动作。  
+ Effects 会订阅 Store 的动作流。  
+ 可通过注入服务来与外部 API 交互并处理流。   

示例：处理加载电影的 Effect  
以下是如何使用 Effects 来处理加载电影的逻辑：  

    import { Injectable, inject } from '@angular/core';
    import { Actions, createEffect, ofType } from '@ngrx/effects';
    import { EMPTY } from 'rxjs';
    import { map, exhaustMap, catchError } from 'rxjs/operators';
    import { MoviesService } from './movies.service';

    @Injectable()
    export class MoviesEffects {
        private actions$ = inject(Actions);
        private moviesService = inject(MoviesService);

        loadMovies$ = createEffect(() => {
            return this.actions$.pipe(
                ofType('[Movies Page] Load Movies'),
                exhaustMap(() => this.moviesService.getAll()
                .pipe(
                    map(movies => ({ type: '[Movies API] Movies Loaded Success', payload: movies })),
                    catchError(() => EMPTY)
                ))
            );
        });
    }

这个 loadMovies$ effect 会监听所有派发的动作，但只对 [Movies Page] Load Movies 感兴趣（通过 ofType 过滤）。动作流随后通过 exhaustMap 展平并映射为新的可观察流。MoviesService#getAll() 方法返回一个 observable，在成功时将电影数据映射为新的动作；如果发生错误，则返回一个空的 observable。该动作会被派发到 Store，由 reducer 处理状态更新。  

注意：事件流不仅限于派发的动作，还可以是任何产生新动作的 observable，例如 Angular Router 的 observable、浏览器事件创建的 observable，以及其他流。    

注册 Effects（副作用处理器）   
Effect 类通过 provideEffects 方法进行注册。  

根级注册  
在应用程序配置的 providers 数组中注册根级 Effects。  
Effects 在实例化后会立即开始运行，以确保尽早监听所有相关动作。  

    import { bootstrapApplication } from '@angular/platform-browser';
    import { provideStore } from '@ngrx/store';
    import { provideEffects } from '@ngrx/effects';

    import { AppComponent } from './app.component';
    import { MoviesEffects } from './effects/movies.effects';
    import * as actorsEffects from './effects/actors.effects';

    bootstrapApplication(AppComponent, {
        providers: [
            provideStore(),
            provideEffects(MoviesEffects, actorsEffects),
        ],
    });

特性级注册Feature-level effects   

特性级 Effects 在路由配置的 providers 数组中注册。使用 provideEffects() 方法注册特性 Effects。  
即使在不同的懒加载特性中多次注册同一个 Effects 类，也不会导致该 Effect 多次运行。  

    import { Route } from '@angular/router';
    import { provideEffects } from '@ngrx/effects';

    import { MoviesEffects } from './effects/movies.effects';
    import * as actorsEffects from './effects/actors.effects';

    export const routes: Route[] = [
        {
            path: 'movies',
            providers: [
            provideEffects(MoviesEffects, actorsEffects)
            ]
        }
    ];

另一种注册方式  
你也可以使用 USER_PROVIDED_EFFECTS 提供器来注册根级或特性级 Effects：  

    providers: [
        MoviesEffects,
        {
            provide: USER_PROVIDED_EFFECTS,
            multi: true,
            useValue: [MoviesEffects],
        },
    ]

整合状态（Incorporating State）  
如果执行 Effect 所需的元数据除了动作类型之外还有其他内容，应通过 props 方法在动作创建器中传递。  
例如，以下是一个带有额外元数据（用户凭证）的登录动作：  

    import { createAction, props } from '@ngrx/store';
    import { Credentials } from '../models/user';

    export const login = createAction(
        '[Login Page] Login',
        props<{ credentials: Credentials }>()
    );

auth.effects.ts

    import { Injectable, inject } from '@angular/core';
    import { Actions, ofType, createEffect } from '@ngrx/effects';
    import { of } from 'rxjs';
    import { catchError, exhaustMap, map } from 'rxjs/operators';
    import {
    LoginPageActions,
    AuthApiActions,
    } from '../actions';
    import { Credentials } from '../models/user';
    import { AuthService } from '../services/auth.service';

    @Injectable()
    export class AuthEffects {
        private actions$ = inject(Actions);
        private authService = inject(AuthService);

        login$ = createEffect(() => {
            return this.actions$.pipe(
            ofType(LoginPageActions.login),
            exhaustMap(action =>
                this.authService.login(action.credentials).pipe(
                map(user => AuthApiActions.loginSuccess({ user })),
                catchError(error => of(AuthApiActions.loginFailure({ error })))
                )
            )
            );  
        });
    }

该登录动作包含额外的 credentials 元数据，并传递给服务以完成登录操作。  

从状态中获取元数据  
有时所需的元数据只能从状态中获取。这时可以使用 RxJS 的 withLatestFrom 或 NgRx 的 concatLatestFrom 操作符来提供状态。  
以下示例展示了 addBookToCollectionSuccess$ Effect 根据收藏书籍数量显示不同的提示：  


    import { Injectable, inject } from '@angular/core';
    import { Store } from '@ngrx/store';
    import { Actions, ofType, createEffect, concatLatestFrom } from '@ngrx/effects';
    import { tap } from 'rxjs/operators';
    import { CollectionApiActions } from '../actions';
    import * as fromBooks from '../reducers';

    @Injectable()
    export class CollectionEffects {
        private actions$ = inject(Actions);
        private store = inject(Store<fromBooks.State>);

        addBookToCollectionSuccess$ = createEffect(
            () => {
            return this.actions$.pipe(
                ofType(CollectionApiActions.addBookSuccess),
                concatLatestFrom(_action => this.store.select(fromBooks.getCollectionBookIds)),
                tap(([_action, bookCollection]) => {
                if (bookCollection.length === 1) {
                    window.alert('恭喜你添加了第一本书！');
                } else {
                    window.alert('你已添加第 ' + bookCollection.length + ' 本书');
                }
                })
            );
            },
            { dispatch: false });
    }

性能提示：使用 concatLatestFrom 等展平操作符可以避免选择器在动作未触发时提前执行。  

使用其他可观察源创建 Effects   
由于 Effects 本质上是可观察流的消费者，因此它们可以在不依赖动作（actions）和 ofType 操作符的情况下使用。这对于那些无需监听特定动作，而是监听其他可观察源的 Effects 非常有用。  

例如，假设我们希望追踪用户的点击事件，并将这些数据发送到监控服务器。我们可以创建一个监听 document 的点击事件的 Effect，并将事件数据发送到服务器。  

user-activity.effects.ts

    import { Injectable, inject } from '@angular/core';
    import { Observable, fromEvent } from 'rxjs';
    import { concatMap } from 'rxjs/operators';
    import { createEffect } from '@ngrx/effects';

    import { UserActivityService } from '../services/user-activity.service';

    @Injectable()
    export class UserActivityEffects {
        private userActivityService = inject(UserActivityService);
        
        trackUserActivity$ = createEffect(() => {
            return fromEvent(document, 'click').pipe(
            concatMap(event => this.userActivityService.trackUserActivity(event)),
            );
        }, { dispatch: false });
    }

这个 Effect 不依赖任何动作类型，而是直接监听浏览器的点击事件，并通过服务将事件数据发送出去。  

# Demo 

1. 生成一个新项目

        ng new my-angular-app --standalone=false --routing --style=css

2. 安装依赖

        npm install @ngrx/store --save    

3. 在app下创建一个名为counter.actions.ts的新文件，以描述增加、减少和重置其值的计数器操作。  

        import { createAction } from '@ngrx/store';

        export const increment = createAction('[Counter Component] Increment');
        export const decrement = createAction('[Counter Component] Decrement');
        export const reset = createAction('[Counter Component] Reset');

4. 在app下创建一个名为counter.reducer.ts的新文件，定义一个 reducer 函数，根据提供的 action 来处理计数器值的变化。  

        import { createReducer, on } from '@ngrx/store';
        import { increment, decrement, reset } from './counter.actions';

        export const initialState = 0;

        export const counterReducer = createReducer(
            initialState,
            on(increment, (state) => state + 1),
            on(decrement, (state) => state - 1),
            on(reset, (state) => 0)
        );

5. 在`app.module.ts`中导入源StoreModule文件@ngrx/store和counter.reducer文件。  

        import { StoreModule } from '@ngrx/store';
        import { counterReducer } from './counter.reducer';

6. 在 AppModule 的 imports 数组中添加 StoreModule.forRoot 函数，并传入一个包含 count 和用于管理计数器状态的 counterReducer 的对象。StoreModule.forRoot() 方法会注册全局的提供者，使整个应用程序都能访问 Store。  

        import { BrowserModule } from '@angular/platform-browser';
        import { NgModule } from '@angular/core';

        import { AppComponent } from './app.component';

        import { StoreModule } from '@ngrx/store';
        import { counterReducer } from './counter.reducer';

        @NgModule({
            declarations: [AppComponent],
            imports: [BrowserModule, StoreModule.forRoot({ count: counterReducer })],
            providers: [],
            bootstrap: [AppComponent],
        })
        export class AppModule {}

7. 在 app 文件夹中创建一个名为 my-counter 的新文件夹，并在其中新建一个名为 my-counter.component.ts 的文件，用于定义一个名为 MyCounterComponent 的新组件。该组件将渲染按钮，允许用户更改计数状态。同时，在同一文件夹中创建一个名为 my-counter.component.html 的文件，用于定义该组件的模板页面。  

        import { Component } from '@angular/core';
        import { Observable } from 'rxjs';

        @Component({
            selector: 'app-my-counter',
            standalone: false,
            templateUrl: './my-counter.component.html',
            styleUrl: './my-counter.component.css'
        })
        export class MyCounterComponent {
            count$: Observable<number>

            constructor() {
                // TODO: Connect `this.count$` stream to the current store `count` state
            }

            increment() {
                // TODO: Dispatch an increment action
            }

            decrement() {
                // TODO: Dispatch a decrement action
            }

            reset() {
                // TODO: Dispatch a reset action
            }
        }

    my-counter.component.html

        <button (click)="increment()">Increment</button>

        <div>Current Count: {{ count$ | async }}</div>

        <button (click)="decrement()">Decrement</button>

        <button (click)="reset()">Reset Counter</button>

8. 将新组件添加到 AppModule 的声明中并在模板app.component.html中声明它：  

        <app-my-counter></app-my-counter>

    app.module.ts

        import { BrowserModule } from '@angular/platform-browser';
        import { NgModule } from '@angular/core';

        import { AppComponent } from './app.component';

        import { StoreModule } from '@ngrx/store';
        import { counterReducer } from './counter.reducer';
        import { MyCounterComponent } from './my-counter/my-counter.component';

        @NgModule({
            declarations: [AppComponent, MyCounterComponent],
            imports: [BrowserModule, StoreModule.forRoot({ count: counterReducer })],
            providers: [],
            bootstrap: [AppComponent],
        })
        export class AppModule {}

9. 将 store 注入到 MyCounterComponent 中，并将 count$ 连接到 store 的 count 状态。通过向 store 分发 action 来实现 increment（递增）、decrement（递减）和 reset（重置）方法。  

        import { Component } from '@angular/core';
        import { Store } from '@ngrx/store';
        import { Observable } from 'rxjs';
        import { decrement, increment, reset } from '../counter.actions';

        @Component({
            selector: 'app-my-counter',
            standalone: false,
            templateUrl: './my-counter.component.html',
            styleUrl: './my-counter.component.css'
        })
        export class MyCounterComponent {
            count$: Observable<number>;

            constructor(private store: Store<{ count: number }>) {
                this.count$ = store.select('count');
            }

            increment() {
                this.store.dispatch(increment());
            }

            decrement() {
                this.store.dispatch(decrement());
            }

            reset() {
                this.store.dispatch(reset());
            }
        }


# Demo 2

1. 生成一个新项目

        ng new book --standalone=false --routing --style=css

2. 安装依赖

        npm install @ngrx/store --save    
  
3. 生成`BookList`组件

        ng g c BookList

4. 在`book-list`文件夹中添加一个`books.model.ts`文件来定义Book接口

        export interface Book {
            id: string;
            volumeInfo: {
            title: string;
            authors: Array<string>;
            };
        }

5. 在app下创建`state`文件夹来管理状态.创建`books.actions.ts`来描述book相关的actions。Book actions包括图书列表的获取、添加图书和移除图书操作。  

        import { createActionGroup, props } from '@ngrx/store';
        import { Book } from '../book-list/books.model';

        export const BooksActions = createActionGroup({
            source: 'Books',
            events: {
                'Add Book': props<{ bookId: string }>(),
                'Remove Book': props<{ bookId: string }>(),
            },
        });

        export const BooksApiActions = createActionGroup({
            source: 'Books API',
            events: {
                'Retrieved Book List': props<{ books: ReadonlyArray<Book> }>(),
            },
        });

6. 在State下创建`books.reducer.ts`在此文件中，定义一个 reducer 函数，用于处理从State中获取图书列表的操作，并相应地更新状态state。

        import { createReducer, on } from '@ngrx/store';

        import { BooksApiActions } from './books.actions';
        import { Book } from '../book-list/books.model';

        export const initialState: ReadonlyArray<Book> = [];

        export const booksReducer = createReducer(
            initialState,
            on(BooksApiActions.retrievedBookList, (_state, { books }) => books)
        );

7. 在 state 文件夹中创建另一个名为 `collection.reducer.ts` 的文件，用于处理更改图书收藏collection的相关操作。定义一个 reducer 函数来处理添加操作，通过将图书的 ID 添加到收藏中。使用同一个 reducer 函数处理移除操作，通过根据图书 ID 过滤收藏数组来实现移除。   

        import { createReducer, on } from '@ngrx/store';
        import { BooksActions } from './books.actions';

        export const initialState: ReadonlyArray<string> = [];

        export const collectionReducer = createReducer(
            initialState,
            on(BooksActions.removeBook, (state, { bookId }) =>
                state.filter((id) => id !== bookId)
            ),
            on(BooksActions.addBook, (state, { bookId }) => {
                if (state.indexOf(bookId) > -1) return state;

                return [...state, bookId];
            })
        );

8. 修改app.module.ts

        import { NgModule } from '@angular/core';
        import { BrowserModule } from '@angular/platform-browser';

        import { AppRoutingModule } from './app-routing.module';
        import { AppComponent } from './app.component';
        import { BookListComponent } from './book-list/book-list.component';
        import { HttpClientModule } from '@angular/common/http';
        import { booksReducer } from './state/books.reducer';
        import { collectionReducer } from './state/collection.reducer';
        import { StoreModule } from '@ngrx/store';

        @NgModule({
            declarations: [
                AppComponent,
                BookListComponent
            ],
            imports: [
                BrowserModule,
                AppRoutingModule,
                StoreModule.forRoot({ books: booksReducer, collection: collectionReducer }),
                HttpClientModule,
            ],
            providers: [],
            bootstrap: [AppComponent]
        })
        export class AppModule { }

9. 创建图书列表和收藏选择器`books.selectors.ts`，以确保我们能够从 store 中获取正确的信息。如你所见，selectBookCollection 选择器通过组合另外两个选择器来构建其返回值。

        import { createSelector, createFeatureSelector } from '@ngrx/store';
        import { Book } from '../book-list/books.model';

        export const selectBooks = createFeatureSelector<ReadonlyArray<Book>>('books');

        export const selectCollectionState = createFeatureSelector<ReadonlyArray<string>>('collection');

        export const selectBookCollection = createSelector(
            selectBooks,
            selectCollectionState,
            (books, collection) => {
                return collection.map((id) => books.find((book) => book.id === id)!);
            }
        );

10. 在 book-list 文件夹中，创建服务`books.service.ts`，用于从 API 获取图书列表所需的数据。该服务将调用 Google Books API 并返回图书列表。  

        ng g s book-list\Book

    books.service.ts  

        import { HttpClient } from '@angular/common/http';
        import { Injectable } from '@angular/core';

        import { Observable } from 'rxjs';
        import { map } from 'rxjs/operators';
        import { Book } from './books.model';

        @Injectable({
            providedIn: 'root'
        })
        export class BookService {

            constructor(private http: HttpClient) {}

            getBooks(): Observable<Array<Book>> {
                return this.http.get<{ items: Book[] }>(
                    'https://www.googleapis.com/books/v1/volumes?maxResults=5&orderBy=relevance&q=oliver%20sacks'
                )
                .pipe(map((books) => books.items || []));
            }
        }

11. 更新`book-list.component.html`以派发添加（add）事件。

        <div
            class="book-item"
            *ngFor="let book of books"
        >
            <p>{{book.volumeInfo.title}}</p><span> by {{book.volumeInfo.authors}}</span>
            <button
                (click)="add.emit(book.id)"
                data-test="add-button"
            >Add to Collection</button>
        </div>

12. 更新`book-list.component.ts`  

        import { Component, EventEmitter, Input, Output } from '@angular/core';
        import { Book } from './books.model';

        @Component({
            selector: 'app-book-list',
            standalone: false,
            templateUrl: './book-list.component.html',
            styleUrl: './book-list.component.css'
        })
        export class BookListComponent {
            @Input() books: ReadonlyArray<Book> = [];
            @Output() add = new EventEmitter<string>();
        }

13. 创建BookCollection组件  

        ng g c BookCollection

14. 更新book-collection.component.html  

        <div 
        class="book-item"
        *ngFor="let book of books"
        >
            <p>{{book.volumeInfo.title}}</p><span> by {{book.volumeInfo.authors}}</span>
            <button
                (click)="remove.emit(book.id)"
                data-test="remove-button"
            >Remove from Collection</button>
        </div>

15. 更新book-collection.component.ts  

        import { Component, EventEmitter, Input, Output } from '@angular/core';
        import { Book } from '../book-list/books.model';

        @Component({
            selector: 'app-book-collection',
            standalone: false,
            templateUrl: './book-collection.component.html',
            styleUrl: './book-collection.component.css'
        })
        export class BookCollectionComponent {
            @Input() books: ReadonlyArray<Book> = [];
            @Output() remove = new EventEmitter<string>();
        }

16. 将 BookListComponent 和 BookCollectionComponent 添加到 AppComponent 的模板中，并在 app.module.ts 中的 declarations 中进行声明

        <h2>Books</h2>
        <app-book-list class="book-list" [books]="(books$ | async)!" (add)="onAdd($event)"></app-book-list>

        <h2>My Collection</h2>
        <app-book-collection class="book-collection" [books]="(bookCollection$ | async)!" (remove)="onRemove($event)">
        </app-book-collection>

17. 在 AppComponent 类中，添加选择器selector以及在调用添加或移除方法时需要派发的对应 action。然后订阅 Google Books API，以便更新状态。（这部分通常应该由 NgRx Effects 处理）  


        import { Component, OnInit } from '@angular/core';
        import { Store } from '@ngrx/store';

        import { selectBookCollection, selectBooks } from './state/books.selectors';
        import { BooksActions, BooksApiActions } from './state/books.actions';
        import { BookService } from './book-list/book.service';

        @Component({
            selector: 'app-root',
            templateUrl: './app.component.html',
            standalone: false,
            styleUrl: './app.component.css'
        })
        export class AppComponent implements OnInit {
            books$: any;
            bookCollection$: any;

            constructor(private booksService: BookService, private store: Store) {}

            ngOnInit() {
                this.books$ = this.store.select(selectBooks);
                this.bookCollection$ = this.store.select(selectBookCollection);
                
                this.booksService
                .getBooks()
                .subscribe((books) =>
                    this.store.dispatch(BooksApiActions.retrievedBookList({ books }))
                );
            }

            onAdd(bookId: string) {
                this.store.dispatch(BooksActions.addBook({ bookId }));
            }

            onRemove(bookId: string) {
                this.store.dispatch(BooksActions.removeBook({ bookId }));
            }
        }


# Reference
[NgRx](https://ngrx.io/docs)  
[Angular与NgRx状态管理: 最佳实践解析](https://www.jianshu.com/p/7a966d2e791d)  
[Level Up Your NgRx Skills With 10 Time-Tested Best Practices](https://angularexperts.io/blog/level-up-your-ng-rx-skills-with-10-time-tested-best-practices)  
[NgRx — Best Practices for Enterprise Angular Applications](https://wesleygrimes.com/angular/2018/05/30/ngrx-best-practices-for-enterprise-angular-applications)  
[Simplify State Management with NgRx in Angular | NgRx Guide](https://codezup.com/simplifying-state-management-ngrx-angular-guide/)  
